{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/Sadiya-Akter-Mim/2nd_round_set_A/blob/main/q1_avl_avl_tree.py\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# avl_tree.py\n",
        "class AVLNode:\n",
        "    def __init__(self, value):\n",
        "        self.value = value\n",
        "        self.left = None\n",
        "        self.right = None\n",
        "        self.height = 1\n",
        "        # Augmented metadata for range sum\n",
        "        self.subtree_sum = value\n",
        "        self.subtree_min = value\n",
        "        self.subtree_max = value\n",
        "\n",
        "def height(node):\n",
        "    return node.height if node else 0\n",
        "\n",
        "def update_metadata(node):\n",
        "    if node is None:\n",
        "        return\n",
        "    node.height = 1 + max(height(node.left), height(node.right))\n",
        "    s = node.value\n",
        "    mn = node.value\n",
        "    mx = node.value\n",
        "    if node.left:\n",
        "        s += node.left.subtree_sum\n",
        "        mn = min(mn, node.left.subtree_min)\n",
        "        mx = max(mx, node.left.subtree_max)\n",
        "    if node.right:\n",
        "        s += node.right.subtree_sum\n",
        "        mn = min(mn, node.right.subtree_min)\n",
        "        mx = max(mx, node.right.subtree_max)\n",
        "    node.subtree_sum = s\n",
        "    node.subtree_min = mn\n",
        "    node.subtree_max = mx\n",
        "\n",
        "def rotate_right(y):\n",
        "    x = y.left\n",
        "    T2 = x.right\n",
        "    x.right = y\n",
        "    y.left = T2\n",
        "    update_metadata(y)\n",
        "    update_metadata(x)\n",
        "    return x\n",
        "\n",
        "def rotate_left(x):\n",
        "    y = x.right\n",
        "    T2 = y.left\n",
        "    y.left = x\n",
        "    x.right = T2\n",
        "    update_metadata(x)\n",
        "    update_metadata(y)\n",
        "    return y\n",
        "\n",
        "def get_balance(node):\n",
        "    if not node:\n",
        "        return 0\n",
        "    return height(node.left) - height(node.right)\n",
        "\n",
        "def insert(node, key):\n",
        "    if node is None:\n",
        "        return AVLNode(key)\n",
        "    if key < node.value:\n",
        "        node.left = insert(node.left, key)\n",
        "    else:\n",
        "        node.right = insert(node.right, key)\n",
        "    update_metadata(node)\n",
        "    balance = get_balance(node)\n",
        "    # Left Left\n",
        "    if balance > 1 and key < node.left.value:\n",
        "        return rotate_right(node)\n",
        "    # Right Right\n",
        "    if balance < -1 and key > node.right.value:\n",
        "        return rotate_left(node)\n",
        "    # Left Right\n",
        "    if balance > 1 and key > node.left.value:\n",
        "        node.left = rotate_left(node.left)\n",
        "        return rotate_right(node)\n",
        "    # Right Left\n",
        "    if balance < -1 and key < node.right.value:\n",
        "        node.right = rotate_right(node.right)\n",
        "        return rotate_left(node)\n",
        "    return node\n",
        "\n",
        "def range_sum(node, L, R):\n",
        "    if node is None:\n",
        "        return 0\n",
        "    # If entire subtree is left of L\n",
        "    if node.subtree_max < L:\n",
        "        return 0\n",
        "    # If entire subtree is right of R\n",
        "    if node.subtree_min > R:\n",
        "        return 0\n",
        "    # If entire subtree inside [L,R]\n",
        "    if node.subtree_min >= L and node.subtree_max <= R:\n",
        "        return node.subtree_sum\n",
        "    s = 0\n",
        "    if L <= node.value <= R:\n",
        "        s += node.value\n",
        "    s += range_sum(node.left, L, R)\n",
        "    s += range_sum(node.right, L, R)\n",
        "    return s\n"
      ],
      "metadata": {
        "id": "1kVrIAfRiqbe"
      },
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "colab": {
      "name": "Welcome To Colab",
      "toc_visible": true,
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}